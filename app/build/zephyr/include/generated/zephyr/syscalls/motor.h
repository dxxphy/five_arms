/* auto-generated by gen_syscalls.py, don't edit */

#ifndef Z_INCLUDE_SYSCALLS_MOTOR_H
#define Z_INCLUDE_SYSCALLS_MOTOR_H


#include <zephyr/tracing/tracing_syscall.h>

#ifndef _ASMLANGUAGE

#include <stdarg.h>

#include <zephyr/syscall_list.h>
#include <zephyr/syscall.h>

#include <zephyr/linker/sections.h>


#ifdef __cplusplus
extern "C" {
#endif

extern float z_impl_motor_get_torque(const struct device * dev);

__pinned_func
static inline float motor_get_torque(const struct device * dev)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		union { uintptr_t x; const struct device * val; } parm0 = { .val = dev };
		return (float) arch_syscall_invoke1(parm0.x, K_SYSCALL_MOTOR_GET_TORQUE);
	}
#endif
	compiler_barrier();
	return z_impl_motor_get_torque(dev);
}

#if defined(CONFIG_TRACING_SYSCALL)
#ifndef DISABLE_SYSCALL_TRACING

#define motor_get_torque(dev) ({ 	float syscall__retval; 	sys_port_trace_syscall_enter(K_SYSCALL_MOTOR_GET_TORQUE, motor_get_torque, dev); 	syscall__retval = motor_get_torque(dev); 	sys_port_trace_syscall_exit(K_SYSCALL_MOTOR_GET_TORQUE, motor_get_torque, dev, syscall__retval); 	syscall__retval; })
#endif
#endif


extern float z_impl_motor_get_speed(const struct device * dev);

__pinned_func
static inline float motor_get_speed(const struct device * dev)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		union { uintptr_t x; const struct device * val; } parm0 = { .val = dev };
		return (float) arch_syscall_invoke1(parm0.x, K_SYSCALL_MOTOR_GET_SPEED);
	}
#endif
	compiler_barrier();
	return z_impl_motor_get_speed(dev);
}

#if defined(CONFIG_TRACING_SYSCALL)
#ifndef DISABLE_SYSCALL_TRACING

#define motor_get_speed(dev) ({ 	float syscall__retval; 	sys_port_trace_syscall_enter(K_SYSCALL_MOTOR_GET_SPEED, motor_get_speed, dev); 	syscall__retval = motor_get_speed(dev); 	sys_port_trace_syscall_exit(K_SYSCALL_MOTOR_GET_SPEED, motor_get_speed, dev, syscall__retval); 	syscall__retval; })
#endif
#endif


extern float z_impl_motor_get_angle(const struct device * dev);

__pinned_func
static inline float motor_get_angle(const struct device * dev)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		union { uintptr_t x; const struct device * val; } parm0 = { .val = dev };
		return (float) arch_syscall_invoke1(parm0.x, K_SYSCALL_MOTOR_GET_ANGLE);
	}
#endif
	compiler_barrier();
	return z_impl_motor_get_angle(dev);
}

#if defined(CONFIG_TRACING_SYSCALL)
#ifndef DISABLE_SYSCALL_TRACING

#define motor_get_angle(dev) ({ 	float syscall__retval; 	sys_port_trace_syscall_enter(K_SYSCALL_MOTOR_GET_ANGLE, motor_get_angle, dev); 	syscall__retval = motor_get_angle(dev); 	sys_port_trace_syscall_exit(K_SYSCALL_MOTOR_GET_ANGLE, motor_get_angle, dev, syscall__retval); 	syscall__retval; })
#endif
#endif


extern int z_impl_motor_set_speed(const struct device * dev, float speed_rpm);

__pinned_func
static inline int motor_set_speed(const struct device * dev, float speed_rpm)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		union { uintptr_t x; const struct device * val; } parm0 = { .val = dev };
		union { uintptr_t x; float val; } parm1 = { .val = speed_rpm };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_MOTOR_SET_SPEED);
	}
#endif
	compiler_barrier();
	return z_impl_motor_set_speed(dev, speed_rpm);
}

#if defined(CONFIG_TRACING_SYSCALL)
#ifndef DISABLE_SYSCALL_TRACING

#define motor_set_speed(dev, speed_rpm) ({ 	int syscall__retval; 	sys_port_trace_syscall_enter(K_SYSCALL_MOTOR_SET_SPEED, motor_set_speed, dev, speed_rpm); 	syscall__retval = motor_set_speed(dev, speed_rpm); 	sys_port_trace_syscall_exit(K_SYSCALL_MOTOR_SET_SPEED, motor_set_speed, dev, speed_rpm, syscall__retval); 	syscall__retval; })
#endif
#endif


extern int z_impl_motor_set_angle(const struct device * dev, float angle);

__pinned_func
static inline int motor_set_angle(const struct device * dev, float angle)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		union { uintptr_t x; const struct device * val; } parm0 = { .val = dev };
		union { uintptr_t x; float val; } parm1 = { .val = angle };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_MOTOR_SET_ANGLE);
	}
#endif
	compiler_barrier();
	return z_impl_motor_set_angle(dev, angle);
}

#if defined(CONFIG_TRACING_SYSCALL)
#ifndef DISABLE_SYSCALL_TRACING

#define motor_set_angle(dev, angle) ({ 	int syscall__retval; 	sys_port_trace_syscall_enter(K_SYSCALL_MOTOR_SET_ANGLE, motor_set_angle, dev, angle); 	syscall__retval = motor_set_angle(dev, angle); 	sys_port_trace_syscall_exit(K_SYSCALL_MOTOR_SET_ANGLE, motor_set_angle, dev, angle, syscall__retval); 	syscall__retval; })
#endif
#endif


extern int z_impl_motor_set_torque(const struct device * dev, float torque);

__pinned_func
static inline int motor_set_torque(const struct device * dev, float torque)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		union { uintptr_t x; const struct device * val; } parm0 = { .val = dev };
		union { uintptr_t x; float val; } parm1 = { .val = torque };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_MOTOR_SET_TORQUE);
	}
#endif
	compiler_barrier();
	return z_impl_motor_set_torque(dev, torque);
}

#if defined(CONFIG_TRACING_SYSCALL)
#ifndef DISABLE_SYSCALL_TRACING

#define motor_set_torque(dev, torque) ({ 	int syscall__retval; 	sys_port_trace_syscall_enter(K_SYSCALL_MOTOR_SET_TORQUE, motor_set_torque, dev, torque); 	syscall__retval = motor_set_torque(dev, torque); 	sys_port_trace_syscall_exit(K_SYSCALL_MOTOR_SET_TORQUE, motor_set_torque, dev, torque, syscall__retval); 	syscall__retval; })
#endif
#endif


extern void z_impl_motor_control(const struct device * dev, enum motor_cmd cmd);

__pinned_func
static inline void motor_control(const struct device * dev, enum motor_cmd cmd)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		union { uintptr_t x; const struct device * val; } parm0 = { .val = dev };
		union { uintptr_t x; enum motor_cmd val; } parm1 = { .val = cmd };
		(void) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_MOTOR_CONTROL);
		return;
	}
#endif
	compiler_barrier();
	z_impl_motor_control(dev, cmd);
}

#if defined(CONFIG_TRACING_SYSCALL)
#ifndef DISABLE_SYSCALL_TRACING

#define motor_control(dev, cmd) do { 	sys_port_trace_syscall_enter(K_SYSCALL_MOTOR_CONTROL, motor_control, dev, cmd); 	motor_control(dev, cmd); 	sys_port_trace_syscall_exit(K_SYSCALL_MOTOR_CONTROL, motor_control, dev, cmd); } while(false)
#endif
#endif


extern int z_impl_motor_set_mode(const struct device * dev, enum motor_mode mode);

__pinned_func
static inline int motor_set_mode(const struct device * dev, enum motor_mode mode)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		union { uintptr_t x; const struct device * val; } parm0 = { .val = dev };
		union { uintptr_t x; enum motor_mode val; } parm1 = { .val = mode };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_MOTOR_SET_MODE);
	}
#endif
	compiler_barrier();
	return z_impl_motor_set_mode(dev, mode);
}

#if defined(CONFIG_TRACING_SYSCALL)
#ifndef DISABLE_SYSCALL_TRACING

#define motor_set_mode(dev, mode) ({ 	int syscall__retval; 	sys_port_trace_syscall_enter(K_SYSCALL_MOTOR_SET_MODE, motor_set_mode, dev, mode); 	syscall__retval = motor_set_mode(dev, mode); 	sys_port_trace_syscall_exit(K_SYSCALL_MOTOR_SET_MODE, motor_set_mode, dev, mode, syscall__retval); 	syscall__retval; })
#endif
#endif


extern void z_impl_motor_limit_speed(const struct device * dev, float max_speed, float min_speed);

__pinned_func
static inline void motor_limit_speed(const struct device * dev, float max_speed, float min_speed)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		union { uintptr_t x; const struct device * val; } parm0 = { .val = dev };
		union { uintptr_t x; float val; } parm1 = { .val = max_speed };
		union { uintptr_t x; float val; } parm2 = { .val = min_speed };
		(void) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_MOTOR_LIMIT_SPEED);
		return;
	}
#endif
	compiler_barrier();
	z_impl_motor_limit_speed(dev, max_speed, min_speed);
}

#if defined(CONFIG_TRACING_SYSCALL)
#ifndef DISABLE_SYSCALL_TRACING

#define motor_limit_speed(dev, max_speed, min_speed) do { 	sys_port_trace_syscall_enter(K_SYSCALL_MOTOR_LIMIT_SPEED, motor_limit_speed, dev, max_speed, min_speed); 	motor_limit_speed(dev, max_speed, min_speed); 	sys_port_trace_syscall_exit(K_SYSCALL_MOTOR_LIMIT_SPEED, motor_limit_speed, dev, max_speed, min_speed); } while(false)
#endif
#endif


extern void z_impl_motor_limit_torque(const struct device * dev, float max_torque, float min_torque);

__pinned_func
static inline void motor_limit_torque(const struct device * dev, float max_torque, float min_torque)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		union { uintptr_t x; const struct device * val; } parm0 = { .val = dev };
		union { uintptr_t x; float val; } parm1 = { .val = max_torque };
		union { uintptr_t x; float val; } parm2 = { .val = min_torque };
		(void) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_MOTOR_LIMIT_TORQUE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_motor_limit_torque(dev, max_torque, min_torque);
}

#if defined(CONFIG_TRACING_SYSCALL)
#ifndef DISABLE_SYSCALL_TRACING

#define motor_limit_torque(dev, max_torque, min_torque) do { 	sys_port_trace_syscall_enter(K_SYSCALL_MOTOR_LIMIT_TORQUE, motor_limit_torque, dev, max_torque, min_torque); 	motor_limit_torque(dev, max_torque, min_torque); 	sys_port_trace_syscall_exit(K_SYSCALL_MOTOR_LIMIT_TORQUE, motor_limit_torque, dev, max_torque, min_torque); } while(false)
#endif
#endif


#ifdef __cplusplus
}
#endif

#endif
#endif /* include guard */
